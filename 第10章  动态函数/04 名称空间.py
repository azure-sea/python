# author azure
#
# ⼆. 命名空间
#  在python解释器开始执行之后, 就会在内存中开辟一个空间, 每当遇到一个变量的时候, 就
# 把变量名和值之间的关系记录下来, 但是当遇到函数定义的时候, 解释器只是把函数名读入内
# 存, 表示这个函数存在了, 至于函数内部的变量和逻辑, 解释器是不关心的. 也就是说一开始
# 的时候函数只是加载进来, 仅此而已, 只有当函数被调用和访问的时候, 解释器才会根据函数
# 内部声明的变量来进行开辟变量的内部空间. 随着函数执行完毕, 这些函数内部变量占用的空
# 间也会随着函数执行完毕而被清空.

# 我们给存放名字和值的关系的空间起一个名字叫: 命名空间. 我们的变量在存储的时候就
# 是存储在这片空间中的.
#  命名空间分类:
#  1. 全局命名空间--> 我们直接在py文件中, 函数外声明的变量都属于全局命名空间
#  2. 局部命名空间--> 在函数中声明的变量会放在局部命名空间
#  3. 内置命名空间--> 存放python解释器为我们提供的名字, list, tuple, str, int这些都是内
# 置命名空间

# 作用域: 作用域就是作用范围, 按照生效范围来看分为 全局作用域和局部作用域
#  全局作用域: 包含内置命名空间和全局命名空间. 在整个文件的任何位置都可以使用(遵循
# 从上到下逐行执行). 局部作用域: 在函数内部可以使用.
#
#  作用域命名空间:
#  1. 全局作用域: 全局命名空间 + 内置命名空间
#  2. 局部作用域: 局部命名空间
#  我们可以通过globals()函数来查看全局作用域中的内容, 也可以通过locals()来查看局部作
#  用域中的变量和函数信息


# a = 10  # 全局名称空间中的内容
#
# def fn():   # fn也在全局名称空间
#     b= 20   # 局部名称空间
#     print(a)
# def gn():
#     print(a)
# fn()
# gn()


# 1. 内置, 2, 全局,  3. 局部(函数调用)

# a= 110 # 全局
# def fn():
#     b= 20 # 局部
#     def gn():  # 局部
#         print(globals())  # 可以查看全局作用域中的内容
#         print(locals())  # 查看当前作用域的内容
#     # print(globals())  # 可以查看全局作用域中的内容
#     # print(locals())   # 查看当前作用域的内容
#     gn()
# def en():
#     pass
# fn()
# # print(globals())  # 可以查看全局作用域中的内容
# # print(locals())   # 查看当前作用域的内容

# 函数嵌套
# def outer():
#     print("哈哈")
#     def inner():
#         print("嘻嘻")
#     inner()
# outer()

# def outer():
#     print("哈哈")
#     def inner_1():
#         print("嘻嘻")
#         def inner_1_1():
#             print("娃娃")
#         inner_1_1()
#     def inner_2():
#         print("呵呵")
#     inner_2()
#     inner_1()
# outer()

# a = 10
# def func():
#     a = 20
# func()
# print(a)

# 在访问func之后把全局中的a换成20

# a = 10  # 全局变量本身就是不安全的, 不能随便修改
# def func():
#     global a  # 1. 可以把全局中的内容引用到函数内部, 2. 在全局没有该变量，便参加一个
#     a = 20
# func()
# print(a)
# def func():
#     global a  # 1. 可以把全局中的内容引用到函数内部, 2. 在全局没有该变量，便参加一个
#     a = 30
# func()
# print(a)